(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{RNAZ:function(n,a,s){"use strict";s.r(a);var e=s("rwtQ"),t=s("q1tI"),l=s.n(t),o=s("Bl7J"),c=s("vrFN"),p=(s("91GP"),s("DbmW"),function(n){var a=n.node,s=a.html,e=a.frontmatter,o=e.date,c=e.subject,p=Object(t.useState)(!1),i=p[0],u=p[1];return l.a.createElement("div",{className:"til-item-container"},l.a.createElement("div",{className:"til-item-btn",onClick:function(){return u(!i)}},l.a.createElement("i",{className:"fas fa-chevron-"+(i?"up":"down")})),l.a.createElement("div",{className:"til-item-date"},o),l.a.createElement("div",{className:"til-item-subjects"},c.map((function(n,a){return l.a.createElement("span",{className:"til-item-subject",key:o+"_sub_"+a},n)}))),l.a.createElement("div",{className:"til-item-content "+(i&&"visible"),dangerouslySetInnerHTML:{__html:s}}))}),i=(s("3cgD"),function(n){var a=n.data;return l.a.createElement(l.a.Fragment,null,l.a.createElement("h1",{className:"til-title"},"Today I Learned 👩🏻‍💻",l.a.createElement("span",{className:"til-subtitle"},"오늘 알게 된 것들")),l.a.createElement("div",{className:"til-items"},a.map((function(n,a){return l.a.createElement(p,Object.assign({},n,{key:"TilItem_"+a}))}))))});a.default=function(){var n=e.data.allMarkdownRemark.edges;return l.a.createElement(o.a,{type:"til"},l.a.createElement(c.a,{title:"TIL"}),l.a.createElement(i,{data:n}))}},rwtQ:function(n){n.exports=JSON.parse('{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>💻 [REACT] 함수형 컴포넌트 hooks</h2>\\n<h3>📍 <code class=\\"language-text\\">useRef</code></h3>\\n<p>함수형 컴포넌트에서 <code class=\\"language-text\\">Ref</code>를 사용하는 방법</p>\\n<ul>\\n<li><code class=\\"language-text\\">Ref</code> : 해당 엘리먼트를 조작할 수 있는 요소, <code class=\\"language-text\\">document.querySelector</code>로 선택해온 것과 유사</li>\\n<li><a href=\\"https://react.vlpt.us/basic/10-useRef.html\\">https://react.vlpt.us/basic/10-useRef.html</a></li>\\n</ul>\\n<h4>☑️ 함수형 컴포넌트와 클래스 컴포넌트의 <code class=\\"language-text\\">Ref</code> 사용 방식이 다른 이유</h4>\\n<h3>📍 <code class=\\"language-text\\">useEffect</code></h3>\\n<ul>\\n<li><a href=\\"https://velog.io/@jepjap93/useEffect%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A7%A7%EC%9D%80-%EA%B0%80%EC%9D%B4%EB%93%9C\\">useEffect에 대한 짧은 가이드</a></li>\\n</ul>\\n<h4>☑️ useEffect 안에서 Ref 사용하기</h4>\\n<blockquote>\\n<p><strong>Ref</strong> : <a href=\\"https://medium.com/@teh_builder/ref-objects-inside-useeffect-hooks-eb7c15198780\\">Ref objects inside useEffect Hooks - Daniel Schmidt - Medium</a></p>\\n</blockquote>\\n<h2>📔 개발자의 글쓰기</h2>\\n<h3>📍 개발 시간을 줄여주는 이름 짓기와 주석 쓰기</h3>\\n<ul>\\n<li>이름 짓기는 창조 과정이 아니라 정해진 원칙으로 적절한 단어를 선택해 조합하는 과정일 뿐이다.</li>\\n</ul>\\n<h2>💻 RN으로 아이폰 가계부를 만들어보자</h2>\\n<p>= 개발환경 설정하다가 끝났음</p>\\n<ul>\\n<li><strong>RN을 선택한 이유</strong> : React를 알고, 자바스크립트에 익숙하니까. 이거 잘 만들면 (언제.. 완성할까?) 출시하고 싶은데, 안드로이드 개발까지 혼자 하기는 어려우니까.</li>\\n<li><strong>참고한 글</strong> : <a href=\\"https://medium.com/@jang.wangsu/rn-react-native%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90%EC%9D%80-6e8a2396eea1\\">React-Native의 장단점은?</a></li>\\n</ul>\\n<h3>📍 React Native 개발환경 설정</h3>\\n<p><strong>공식 문서</strong> : <a href=\\"https://reactnative.dev/docs/getting-started\\">Getting Started · React Native</a></p>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">// xcode도 설치되어 있어야 함\\n$ brew install watchman\\n$ npm install -g react-native-cli\\n$ npx react-native run-ios   // ios 실행 명령</code></pre></div>\\n<h2>😈 brew: command not found 오류</h2>\\n<p><a href=\\"https://kgu0724.tistory.com/90\\">macOS용 Homebrew 설치 (bash: brew: command not found)</a></p>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”\\n\\n출처: https://kgu0724.tistory.com/90 [병아리 개발자의 이야기]</code></pre></div>\\n<h2>😈 RN <code class=\\"language-text\\">pod install</code> 오류</h2>\\n<img width=\\"600px\\" src=\\"https://user-images.githubusercontent.com/42922453/76943336-86e2f400-6942-11ea-984f-9dd93c311545.png\\">\\n<p><code class=\\"language-text\\">pod install</code> 커맨드를 실행하면 <code class=\\"language-text\\">glog</code> 부분에서 오류가 발생함</p>\\n<blockquote>\\n<p><strong>해결 방법</strong> : <a href=\\"https://github.com/facebook/react-native/issues/25561#issuecomment-510856359\\">링크</a></p>\\n</blockquote>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">$ sudo xcode-select —switch /Applications/Xcode.app\\n$ cd ios &amp;&amp; pod install</code></pre></div>\\n<h2>😈 node를 설치했는데 매번 못찾을 때</h2>\\n<p><code class=\\"language-text\\">nvm</code>으로 node를 설치했는데, 터미널을 열 때마다 못찾는다. 그래서 RN 프로젝트를 빌드하면 <strong>’Can’t find ‘node’ binary to build React Native bundle’</strong> 라는 에러가 발생했다.</p>\\n<blockquote>\\n<p><strong>해결 방법</strong> : <a href=\\"https://github.com/facebook/react-native/issues/22918#issuecomment-455960705\\">Can’t find ‘node’ binary to build React Native bundle · Issue #22918 · facebook/react-native · GitHub</a></p>\\n</blockquote>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">// 단, node 명령어가 정상적으로 실행되는 상태여야 함\\n// 내 경우 nvm use stable로 stable 버전의 node를 실행시키고 아래 명령어를 실행했음\\n$ ln -s $(which node) /usr/local/bin/node</code></pre></div>\\n<hr>\\n<h2>👻 Today..</h2>\\n<p>오늘은 약간 공부는 하기 싫고, 이것저것 키보드를 두드려보고 싶은 날이었다. 근데 개발환경 설정할 때마다 오류 너무 많이 난다.. React Hooks 정리하려고 했는데. 내일 하지 뭐.</p>","frontmatter":{"subject":["useRef"],"date":"2020-03-18"}}},{"node":{"html":"<h2>💻 GraphiQL : GraphQL Query를 돕는 도구</h2>\\n<p><a href=\\"https://github.com/graphql/graphiql/tree/master/packages/graphiql#readme\\">https://github.com/graphql/graphiql/tree/master/packages/graphiql#readme</a></p>\\n<ul>\\n<li>Gatsby에서는 <code class=\\"language-text\\">gatsby develop</code>로 개발 서버를 띄우고, <code class=\\"language-text\\">localhost:8000/__graphql</code>로 접속하면 된다.</li>\\n</ul>\\n<h2>🌏 RSS(Rich Site Summary)</h2>\\n<p>뉴스나 블로그 사이트에서 주로 사용하는 <strong>컨텐츠 표현 방식</strong></p>\\n<ul>\\n<li>웹 기반형과 설치형이 있음</li>\\n<li><strong>웹 기반형</strong> : 간단한 계정 등록으로 어디에서든 이용할 수 있음</li>\\n<li>RSS 이전에는 원하는 정보를 얻기 위해 해당 사이트를 직접 방문해야 했으나, RSS로 자동 수집이 가능해졌기 때문에 사용자가 각 사이트의 방문 없이 최신 정보만 골라 볼 수 있음</li>\\n<li>팟캐스트같은 <strong>미디어 배포 용도</strong>로도 사용됨 * RSS 2.0의 <code class=\\"language-text\\">&lt;enclosure&gt;</code> 태그 내에 MP3, MOV 등의 미디어 파일을 첨부하면 클라이언트에서 해당 파일을 받아 이용할 수 있음</li>\\n</ul>\\n<blockquote>\\n<p><strong>Ref</strong> : <a href=\\"https://ko.wikipedia.org/wiki/RSS\\">RSS - 위키백과, 우리 모두의 백과사전</a></p>\\n</blockquote>\\n<h2>🌏 운영체제 개념 공부 (면접대비)</h2>\\n<h3>📍 IPC(Inter Process Communication)</h3>\\n<blockquote>\\n<p><strong>Ref</strong> : <a href=\\"https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operation%20System/IPC(Inter%20Process%20Communication).md\\">tech-interview-for-developer/IPC(Inter Process Communication).md at master · gyoogle/tech-interview-for-developer · GitHub</a></p>\\n</blockquote>\\n<p>프로세스 간의 통신을 위한 기술</p>\\n<ul>\\n<li><strong>프로세스</strong> : 다른 프로세스와 자원을 공유하지 않는 독립된 실행 흐름</li>\\n<li>프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신이 가능</li>\\n<li><strong><a href=\\"https://webdir.tistory.com/110\\">커널(kernel)</a></strong> : 운영체제의 핵심 영역으로, 다른 모든 부분에 여러 기본적인 서비스를 제공함</li>\\n<li>IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 세마포어와 뮤텍스를 사용</li>\\n</ul>\\n<h4>☑️ 익명 PIPE</h4>\\n<ul>\\n<li>두 개의 프로세스를 파이프가 연결하고, 한 프로세스는 읽기만, 한 프로세스는 쓰기만 가능</li>\\n<li>한쪽 방향으로만 통신이 가능한 반이중 통신</li>\\n<li>통신할 프로세스를 명확히 알 수 있는 경우(예: 부모-자식 프로세스 간 통신)에 사용</li>\\n<li>양방향 송/수신을 위해서는 2개의 파이프가 필요(구현이 복잡해짐)</li>\\n<li>단순한 데이터 흐름을 가질 때는 파이프를 사용하는 것이 효율적</li>\\n</ul>\\n<h4>☑️ Named PIPE(FIFO)</h4>\\n<ul>\\n<li>전혀 모르는 상태의 프로세스 간 통신에 사용</li>\\n<li>익명 파이프의 확장된 상태로 부모 프로세스와 무관한 다른 프로세스도 통신이 가능</li>\\n<li>통신을 위해 이름있는 파일을 사용</li>\\n<li>동시 송/수신은 불가하며, 익명 파이프처럼 2개를 만들어야 가능</li>\\n</ul>\\n<h4>☑️ Message Queue</h4>\\n<ul>\\n<li>입출력 방식은 Named 파이프와 동일함</li>\\n<li>데이터의 흐름이 아니라 메모리 공간을 가리킴</li>\\n<li>사용할 데이터에 번호를 붙이면서 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있음</li>\\n</ul>\\n<h4>☑️ 공유 메모리(Shared Memory)</h4>\\n<ul>\\n<li>프로세스 간 메모리 영역을 공유해서 사용할 수 있도록 허용</li>\\n<li>프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해주고, 이후 모든 프로세스는 해당 메모리 영역에 접근할 수 있음</li>\\n<li>중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC 중에 <strong>가장 빠르게</strong> 작동함</li>\\n</ul>\\n<h4>☑️ 메모리 맵</h4>\\n<ul>\\n<li>열린 파일을 메모리에 매핑시켜서 공유</li>\\n<li>파일로 대용량 데이터를 공유해야 할 때 사용</li>\\n</ul>\\n<h4>☑️ 소켓</h4>\\n<ul>\\n<li>네트워크 소켓 통신을 통해 데이터를 공유</li>\\n<li>클라이언트와 서버가 소켓을 통해 통신하는 구조</li>\\n<li>원격에서 프로세스 간 데이터를 공유할 때 사용</li>\\n<li>서버(bind, listen, accept), 클라이언트(connect)</li>\\n</ul>\\n<h3>📍 세마포어(Semaphore) &#x26; 뮤텍스(Mutex)</h3>\\n<blockquote>\\n<p><strong>Ref</strong> : <a href=\\"https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operation%20System/Semaphore%20%26%20Mutex.md\\">tech-interview-for-developer/Semaphore &#x26; Mutex.md at master · gyoogle/tech-interview-for-developer · GitHub</a></p>\\n</blockquote>\\n<p>공유 자원에 동시 접근을 제한하기 위한 방법</p>\\n<h4>☑️ 세마포어(Semaphore)</h4>\\n<p>멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법</p>\\n<ul>\\n<li><strong>임계 구역(Critical Section)</strong> : 프로세스가 데이터를 공유할 때, 각 프로세스에서 공유 데이터에 접근하는 프로그램 코드 부분</li>\\n<li>공유 데이터에 프로세스가 동시 접근하면 잘못된 결과를 만들 수 있다.</li>\\n</ul>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">P: 임계 구역 진입 전에 수행 (진입 여부 결정)\\nS: 임계 구역에서 나올 때 수행 (자원 반납)</code></pre></div>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">— S가 1이면 접근 가능 상태\\nprocedure P(S)\\n  while S = 0 do wait\\n  S := S - 1     // 다른 프로세스 접근할 수 없도록\\nend P\\n\\n— 임계 구역 —\\n\\nprocedure V(S)\\n  S := S + 1     // 다른 프로세스 접근할 수 있도록\\nend V</code></pre></div>\\n<h4>☑️ 뮤텍스(Mutex)</h4>\\n<p>임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술 (상호배제)</p>\\n<ul>\\n<li><code class=\\"language-text\\">lock</code> : 임계 구역에 들어갈 권한을 얻음</li>\\n<li><code class=\\"language-text\\">unlock</code> : 현재 임계 구역을 모두 사용했음을 알림</li>\\n<li>뮤텍스는 상태가 0, 1로 <strong>이진 세마포어</strong>로 부르기도 함</li>\\n</ul>\\n<div class=\\"gatsby-highlight\\" data-language=\\"js\\"><pre class=\\"language-js\\"><code class=\\"language-js\\"><span class=\\"token comment\\">// 데커(Dekker) 알고리즘</span>\\n<span class=\\"token keyword\\">while</span> <span class=\\"token punctuation\\">(</span><span class=\\"token boolean\\">true</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n    flag<span class=\\"token punctuation\\">[</span>i<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">=</span> <span class=\\"token boolean\\">true</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token keyword\\">while</span> <span class=\\"token punctuation\\">(</span>flag<span class=\\"token punctuation\\">[</span>j<span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n        <span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span>turn <span class=\\"token operator\\">===</span> j<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n            flag<span class=\\"token punctuation\\">[</span>i<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">=</span> <span class=\\"token boolean\\">false</span><span class=\\"token punctuation\\">;</span>\\n            <span class=\\"token keyword\\">while</span> <span class=\\"token punctuation\\">(</span>turn <span class=\\"token operator\\">===</span> j<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span><span class=\\"token punctuation\\">}</span>\\n            flag<span class=\\"token punctuation\\">[</span>i<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">=</span> <span class=\\"token boolean\\">true</span><span class=\\"token punctuation\\">;</span>\\n        <span class=\\"token punctuation\\">}</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span>\\n\\n<span class=\\"token comment\\">// 임계 구역</span>\\n\\nturn <span class=\\"token operator\\">=</span> j<span class=\\"token punctuation\\">;</span>\\nflag<span class=\\"token punctuation\\">[</span>i<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">=</span> <span class=\\"token boolean\\">false</span><span class=\\"token punctuation\\">;</span></code></pre></div>\\n<p><code class=\\"language-text\\">flag</code>와 <code class=\\"language-text\\">turn</code> 변수를 통해 임계 구역에 들어갈 프로세스/스레드를 결정하는 방식</p>\\n<ul>\\n<li><code class=\\"language-text\\">flag</code> : 프로세스 중 누가 임계영역에 진입할 것인지 나타내는 변수</li>\\n<li><code class=\\"language-text\\">turn</code> : 누가 임계구역에 들어갈 차례인지 나타내는 변수</li>\\n</ul>\\n<div class=\\"gatsby-highlight\\" data-language=\\"js\\"><pre class=\\"language-js\\"><code class=\\"language-js\\"><span class=\\"token comment\\">// 피터슨(Peterson) 알고리즘</span>\\n<span class=\\"token keyword\\">while</span> <span class=\\"token punctuation\\">(</span><span class=\\"token boolean\\">true</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n    flag<span class=\\"token punctuation\\">[</span>i<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">=</span> <span class=\\"token boolean\\">true</span><span class=\\"token punctuation\\">;</span>\\n    turn <span class=\\"token operator\\">=</span> j<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token keyword\\">while</span> <span class=\\"token punctuation\\">(</span>flag<span class=\\"token punctuation\\">[</span>j<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">&amp;&amp;</span> turn <span class=\\"token operator\\">===</span> j<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span><span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span>\\n\\n<span class=\\"token comment\\">// 임계 구역</span>\\n\\nflag<span class=\\"token punctuation\\">[</span>i<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">=</span> <span class=\\"token boolean\\">false</span><span class=\\"token punctuation\\">;</span></code></pre></div>\\n<p>데커와 유사하지만, 상대방 프로세스/스레드에 진입 기회를 양보함</p>\\n<div class=\\"gatsby-highlight\\" data-language=\\"js\\"><pre class=\\"language-js\\"><code class=\\"language-js\\"><span class=\\"token comment\\">// 제과점(Bakery) 알고리즘</span>\\n<span class=\\"token keyword\\">while</span><span class=\\"token punctuation\\">(</span><span class=\\"token boolean\\">true</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n  isReady<span class=\\"token punctuation\\">[</span>i<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">=</span> <span class=\\"token boolean\\">true</span><span class=\\"token punctuation\\">;</span>\\n  number<span class=\\"token punctuation\\">[</span>i<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">=</span> <span class=\\"token function\\">max</span><span class=\\"token punctuation\\">(</span>number<span class=\\"token punctuation\\">[</span><span class=\\"token number\\">0</span><span class=\\"token operator\\">~</span>n<span class=\\"token operator\\">-</span><span class=\\"token number\\">1</span><span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">+</span> <span class=\\"token number\\">1</span><span class=\\"token punctuation\\">;</span>\\n  isReady<span class=\\"token punctuation\\">[</span>i<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">=</span> <span class=\\"token boolean\\">false</span><span class=\\"token punctuation\\">;</span>\\n\\n  <span class=\\"token keyword\\">for</span><span class=\\"token punctuation\\">(</span>j <span class=\\"token operator\\">=</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">;</span> j <span class=\\"token operator\\">&lt;</span> n<span class=\\"token punctuation\\">;</span> j<span class=\\"token operator\\">++</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token keyword\\">while</span><span class=\\"token punctuation\\">(</span>isReady<span class=\\"token punctuation\\">[</span>j<span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span> <span class=\\"token punctuation\\">}</span>\\n    <span class=\\"token keyword\\">while</span><span class=\\"token punctuation\\">(</span>number<span class=\\"token punctuation\\">[</span>j<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">&amp;&amp;</span> number<span class=\\"token punctuation\\">[</span>j<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">&lt;</span> number<span class=\\"token punctuation\\">[</span>i<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">&amp;&amp;</span> j <span class=\\"token operator\\">&lt;</span> i<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span> <span class=\\"token punctuation\\">}</span>\\n  <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span>\\n\\n<span class=\\"token comment\\">// 임계 구역</span>\\n\\nnumber<span class=\\"token punctuation\\">[</span>i<span class=\\"token punctuation\\">]</span> <span class=\\"token operator\\">=</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">;</span></code></pre></div>\\n<hr>\\n<h2>👻 Today..</h2>\\n<p>오늘은 여행 다녀와서 짧게만 공부. 오랜만에 다시 찾아보는 개념들이라서 아, 이랬지 하는 것도 있고 그 때는 별 생각없이 지나친 개념들도 있다. 운영체제는 학교 수업으로 배울 땐 진짜 이해하기 힘든데 따로 공부하면 그렇게 재밌을수가 없는 듯.. 내일 마저 공부해야지.</p>","frontmatter":{"subject":["RSS","IPC","세마포어","뮤텍스"],"date":"2020-03-17"}}},{"node":{"html":"<h2>📔 리얼월드 HTTP - 4.1 통신 고속화</h2>\\n<p>HTTP/1.1의 대표적인 기능은 TLS를 통한 안전한 통신 제공과 Keep-Alive, 파이프라이닝의 통신고속화</p>\\n<h3>📍 Keep-Alive</h3>\\n<p>HTTP의 아래층은 TCP/IP 통신을 효율화하는 구조</p>\\n<ul>\\n<li><strong>Keep-Alive 이전</strong> : 하나의 요청마다 통신을 닫아야 함</li>\\n<li><strong>Keep-Alive 사용</strong> : 연속된 요청에는 접속을 다시 이용</li>\\n<li>TCP/IP 통신의 접속까지의 대기 시간이 줄어들고, 통신 처리량이 많아져서 속도가 올라간 것처럼 느껴짐</li>\\n</ul>\\n<h4>☑️ <code class=\\"language-text\\">Keep-Alive</code> 사용</h4>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">Connection: Keep-Alive</code></pre></div>\\n<ul>\\n<li>위 헤더를 받아들인 서버가 <code class=\\"language-text\\">Keep-Alive</code>를 지원하면, 같은 헤더를 응답 헤더에 추가해서 반환</li>\\n<li>HTTP/1.1에서는 이 동작이 기본</li>\\n<li>TLS 통신을 이용할 경우 <code class=\\"language-text\\">Keep-Alive</code>가 특히 통신 시간 감소에 효율적</li>\\n<li><strong>RTT(round-trip time)</strong> : 패킷이 1회 왕복하는 시간\\n_ TCP/IP는 접속할 때 1.5회 왕복 통신 필요 (1.5RTT 시간 소요)\\n_ TLS는 서버/클라이언트 통신 시작 전 핸드셰이크(handshake)에서 2RTT의 시간 소요</li>\\n</ul>\\n<h4>☑️ <code class=\\"language-text\\">Keep-Alive</code> 종료</h4>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">Connection: Close</code></pre></div>\\n<ul>\\n<li>클라이언트나 헤더 한 쪽에서 위 헤더를 사용해 접속을 종료</li>\\n<li><strong>다른 방법</strong> : 타임아웃 될 때까지 기다리기</li>\\n<li>자바스크립트를 이용해서 동적으로 요청을 보낼 수 있기 때문에, HTML 정적 분석으로 클라이언트 통신의 완료를 탐지하기 어려움</li>\\n<li><code class=\\"language-text\\">Keep-Alive</code> 종료를 명시적으로 보내는 것보다는, <strong>타임아웃으로 접속 종료를 기다리는 것이 일반적</strong></li>\\n<li>한 쪽이 TCP/IP 연결을 끊는 순간에 통신이 완료되므로, 클라이언트나 서버 중 <code class=\\"language-text\\">Keep-Alive</code> 지속시간이 짧은 쪽이 사용됨 * 각 브라우저나 서버마다 시간이 다름</li>\\n<li>통신이 지속되는 동안 OS 자원을 소비하므로, 사용하지 않으면 빨리 끊는 것이 바람직</li>\\n</ul>\\n<h3>📍 파이프라이닝</h3>\\n<p>최초의 요청이 완료되기 전에 다음 요청을 보내는 기술</p>\\n<ul>\\n<li>다음 요청까지의 대기 시간을 없앰으로써, 네트워크 가동률을 높이고 성능을 향상함</li>\\n<li><code class=\\"language-text\\">Keep-Alive</code> 이용을 전제로 함</li>\\n<li>서버는 요청이 들어온 순서대로 응답을 반환함</li>\\n</ul>\\n<blockquote>\\n<p>구현되어있어도 꺼져있는 경우가 많고, 제대로 동작하지 않는 경우가 많음. 기본 활성화 된 브라우저는 오페라, iOS 5 이후의 사파리 정도 뿐. 성능이 거의 좋아지지 않는다는 보고도 있음.</p>\\n</blockquote>\\n<ul>\\n<li><strong>HOL(head-of-line) 블로킹 문제</strong> : 요청 받은 순서대로 응답해야 하므로, 응답 생성에 시간이 걸리거나 크기가 큰 파일을 반환하는 처리가 있으면 다른 응답에 영향을 줌</li>\\n<li>파이프라이닝을 지원하지 않는 서버를 위해 초기에 확인을 위한 요청을 보내야 하기 때문에, 성능을 제대로 살리지 못했다는 문제도 있음</li>\\n<li><strong>결론</strong> : 좋은 점이 있지만, 다양한 문제때문에 그대로 사용되지는 않는다.</li>\\n</ul>\\n<blockquote>\\n<p>파이프라인은 여러 문제를 해결하고 HTTP/2에서 스트림이라는 새로운 구조로 재탄생 함 🎉</p>\\n</blockquote>\\n<h2>📔 리얼월드 HTTP - 4.2 전송 계층 보안(TLS)</h2>\\n<p>통신 경로를 암호화하는 기술</p>\\n<ul>\\n<li><strong>SSL(Secure Sockets Layer)</strong> : 보안 소켓 계층 * TLS는 SSL 3.0을 바탕으로 1996년에 표준화 시작되어 HTTP/1.1 이후 완성됨</li>\\n<li>기존 프로토콜에 통신 경로의 안전성을 추가해 새로운 프로토콜을 만들어낼 수 있는 범용적인 구조</li>\\n<li>HTTPS 포트는 443번을 사용해 HTTP(80번)와 다른 서비스로 취급됨</li>\\n<li>메일 전송 프로토콜 SMTP(25번)의 TLS 버전인 SMTPS(465번) 등 기존 프로토콜 버전 업에도 사용</li>\\n<li>TLS는 SSL이라 불리는 경우도 많지만, 실제 SSL은 여러 취약성이 알려져 있어, RFC에서도 권장하지 않음</li>\\n<li>✅ TLS는 통신 경로 밖의 정보는 숨겨주지 않으므로, 사용자 정보를 평문으로 저장하지 않고 해시화해서 보호하는 것은 TLS와 관계없이 꼭 필요</li>\\n</ul>\\n<blockquote>\\n<p>중간자가 통신을 감청하거나 통신 내용을 변경하거나 클라이언트로 속여 요청을 보낼 수 있지만, TLS는 이러한 상태에서 도청, 조작, 사칭이 불가한 통신을 제공함</p>\\n</blockquote>\\n<h3>📍 해시 함수</h3>\\n<p>입력 데이터를 규칙에 따라 집약해감으로써 <strong>해시 값으로 불리는 짧은 데이터를 생성</strong>함</p>\\n<ul>\\n<li><strong>해시</strong> : ‘잘게 저민 조각‘ 이라는 뜻</li>\\n</ul>\\n<h4>☑️ 해시 함수의 수학적 특성</h4>\\n<ul>\\n<li>같은 알고리즘과 같은 입력데이터라면 결과로 생성되는 값은 항상 같다.</li>\\n<li>해시 값은 알고리즘이 같으면 길이가 고정된다.</li>\\n<li><strong>약한 충돌 내성</strong> : 해시 값에서 원래 데이터를 유추하기 어렵다.</li>\\n<li><strong>강한 충돌 내성</strong> : 같은 해시 값을 생성하는 다른 두 개의 데이터를 찾기 어렵다.</li>\\n</ul>\\n<blockquote>\\n<p>다운로드 한 파일이 깨지지 않았는지 확인할 때도 사용됨. (체크섬, 핑거프린트로 불림)</p>\\n</blockquote>\\n<h4>☑️ 유명 해시 함수</h4>\\n<p>MD5(128비트), SHA-1(160비트), SHA-2(SHA-224, SHA256, SHA-384 …) 등이 있음</p>\\n<blockquote>\\n<p>2016년 MD5, SHA-1은 보안 용도로 비추천 (뚫렸음)</p>\\n</blockquote>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">$ md5 index.rst\\nMD5 (index.rst) = 0918298fa0d9109348ds0f …</code></pre></div>\\n<h3>📍 공통 키 암호, 공개 키 암호, 디지털 서명</h3>\\n<ul>\\n<li>암호화에서 중요한 것은 알고리즘 자체를 비밀로 하는 것이 아니라, <strong>알고리즘이 알려져도 안전하게 통신</strong>할 수 있는 것</li>\\n<li>물리적 세계에서 은닉화는 키를 숨기는 것이지만, <strong>암호화는 키로 원본 데이터를 파괴</strong>하는 것</li>\\n<li><strong>일반적으로 사용하는 방식</strong> : 암호화 알고리즘은 공개하고, 암호화에 사용하는 키를 따로 준비하는 방식</li>\\n<li>TLS에서는 <strong>공통 키 방식</strong>과 <strong>공개 키 방식</strong> 두 종류가 있음</li>\\n</ul>\\n<h4>☑️ 공통 키 방식(대칭 암호)</h4>\\n<p>자물쇠를 잠글 때, 열 때 모두 같은 열쇠를 사용하는 방식</p>\\n<ul>\\n<li>통신하는 사람끼리 번호(키)를 공유해야 함</li>\\n<li>키로 원본 데이터를 파괴하고, 받은 쪽에서는 가지고 있던 키로 데이터를 복원해서 읽음</li>\\n<li>TLS에서 일반 통신의 암호화에 사용함</li>\\n</ul>\\n<h4>☑️ 공개 키 방식(비대칭 암호)</h4>\\n<ul>\\n<li>공개 키(자물쇠)로 암호화하고, 비밀 키(열쇠)로 해독함</li>\\n<li>암호화 된 데이터로 원본을 복원할 수는 있어도 자물쇠인 비밀 키를 추출할 수 없음</li>\\n<li><strong>디지털 서명</strong> : 비밀 키로 암호화 한 데이터를 보내면, 받은 사람이 공개 키로 데이터를 해독하고, 해독이 되면 해당 사람이 보낸 것이 확인 되는 원리</li>\\n</ul>\\n<blockquote>\\n<p>실제 디지털 서명은 본문 자체를 암호화 하는 것이 아니라, 먼저 해시화하고 그 결과를 암호화 함</p>\\n</blockquote>\\n<p>암호화는 완벽하지 않고, 현실적인 시간 내에서 해석이 가능한 경우 보안에 취약한 것으로 간주됨</p>\\n<h3>📍 키 교환</h3>\\n<p>클라이언트와 서버 사이에 키를 교환하는 것</p>\\n<ul>\\n<li><strong>간단한 방법</strong> : 공통 키를 생성한 다음, 서버 인증서의 공개 키로 암호화해서 전송</li>\\n<li><strong>키 교환 전용 알고리즘</strong> : 여러 가지 중 DH(디피-헬먼) 알고리즘이 있음 * 키 자체를 교환하는 것이 아니라, 각각 키 재료를 만들어 서로 교환하고 각자 계산해서 같은 키 얻음</li>\\n<li><strong>ECDHE(타원곡선 디피-헬먼) 알고리즘</strong> : 더 적은 비트 수를 사용해서 훨씬 강한 강도를 가짐</li>\\n</ul>\\n<blockquote>\\n<p>공통 키의 안전한 교환을 위해서 <strong>경로에서 관측하는 것만으로 키를 찾아내기 어려운 키 교환 알고리즘</strong>을 이용하는 것. 이 방법은 중간에 내용을 변경하는 공격에 약하므로, ✅ 인증서 인증을 함께 사용해서 조작 위험성을 줄임.</p>\\n</blockquote>\\n<h3>📍 공통 키, 공개 키 방식 구분해서 사용하는 이유</h3>\\n<p>공개 키 방식은 안전성이 높지만, 암호화/복호화에 필요한 연산량이 공통 키 방식보다 많아서 TLS는 두 가지 방식을 혼합해서 사용하고 있음</p>\\n<h4>☑️ TLS의 2단계 방식</h4>\\n<ol>\\n<li>통신마다 한 번만 사용되는 공통 키를 만들고, 공개 키를 사용해 통신 상대에게 키를 전송함</li>\\n<li>이후 공통 키로 고속 암호화</li>\\n</ol>\\n<h3>📍 TLS 통신 절차</h3>\\n<ol>\\n<li>핸드셰이크 프로토콜로 통신을 확립하는 단계</li>\\n<li>레코드 프로토콜로 불리는 통신 단계</li>\\n<li><code class=\\"language-text\\">SessionTicket</code> 구조를 이용한 재접속 시 고속 핸드셰이크 단계</li>\\n</ol>\\n<h4>☑️ 서버의 신뢰성 확인</h4>\\n<ul>\\n<li>브라우저는 서버에서 서버의 SSL 서버 인증서를 가져옴 * <strong>인증서 정보</strong> : 사이트 주체(이름과 도메인), <strong>발행자 서명</strong>(인증 기관, CA), 소유자 서버 공개 키, 유효 기한 등</li>\\n<li>발행자의 인증서를 취득해서 서명을 검증 (상위 발행자 인증서도 차례로 검증)</li>\\n<li>발행자와 주체자가 동일한 인증서(루트 인증기관)까지 인증해서 서버가 승인된 것을 확인</li>\\n<li><strong>자가 서명 인증서</strong> : 신뢰가 확인되지 않은 발행자와 주체가 같은 인증서\\n_ OpenSSL 등의 도구로 손쉽게 만들 수 있음\\n_ 직접 만든 인증서를 OS에 등록해서 개인용 서비스 인증에 사용하거나 사내 전용 서버 확인에 사용 가능</li>\\n<li>서명 작성에 SHA-1 알고리즘을 이용한 인증서는 2016년부터 발행이 금지되고, 2017년부터 사용이 금지됨</li>\\n</ul>\\n<blockquote>\\n<p>✅ 인증서의 안전성은 공개 키 기반으로 발행자가 보증함</p>\\n</blockquote>\\n<h4>☑️ 키 교환과 통신 시작</h4>\\n<p>키 교환은 공개 키 암호 사용 방식과 키 교환 전용 알고리즘 사용 방식이 있음</p>\\n<ul>\\n<li><strong>공개 키 암호 방식</strong> : 통신용 공통 키를 서버 인증서에 첨부된 공개 키로 암호화해서 서버로 전달</li>\\n<li><strong>키 교환 알고리즘 방식</strong> : 키를 생성할 시드를 양측에서 하나씩 만들고, 서로 교환해서 계산한 결과가 공통 키\\n_ ✅ 순방향 비밀성(forward secrecy)이 우수함\\n_ 동적으로 계산되고 파일로 저장되지 않기 때문에 키가 유출될 일이 없음</li>\\n</ul>\\n<h4>☑️ 통신</h4>\\n<p>통신을 할 때도 기밀성과 무결성 위해 암호화가 필요하며, <strong>공통 키 암호 방식 알고리즘</strong>을 사용함</p>\\n<ul>\\n<li><strong>TLS 1.2 이전</strong> : 통신 내용 해시 값 계산 후, 공통 키 암호로 암호화 (전송 내용의 바이트 열에서 생성한 해시 값을 전송 데이터 끝에 붙여 조작을 탐지)</li>\\n<li><strong>TLS 1.3 이후</strong> : 위 기법에 대한 공격이 발견되어 <code class=\\"language-text\\">AES+GCM</code>, <code class=\\"language-text\\">AES+CCM</code>, <code class=\\"language-text\\">ChaCha20-Poly1305</code> 등의 인증 암호로 제한될 예정 * (예) <code class=\\"language-text\\">AES+GCM</code> : 일반 공통 키와 별개로 12바이트의 키가 필요하며, 8바이트는 랜덤하게 만들어서 부여하고, 4바이트는 핸드셰이크 때 교환한 난수를 재료로 해시 함수를 이용해서 생성</li>\\n</ul>\\n<h4>☑️ 통신의 고속화</h4>\\n<p>지금까지의 과정은 신규 접속의 흐름이고, 일반 접속에서는</p>\\n<ul>\\n<li>TCP/IP 단계 1.5RTT</li>\\n<li>TLS 핸드셰이크 2RTT</li>\\n<li>HTTP 요청 1RTT\\n로, 합계가 4RTT가 소요됨. (TLS 사용하지 않으면 2RTT)</li>\\n</ul>\\n<blockquote>\\n<p>TCP/IP 통신 마지막의 0.5RTT와 TLS 최초 통신이 함께 이루어지기 때문에</p>\\n</blockquote>\\n<ul>\\n<li>통신에서 전기 신호가 도달하고 응답 오기까지 시간은 매우 긴 시간이므로, 왕복 시간을 줄여야 함</li>\\n<li>TLS, HTTP에서는 <code class=\\"language-text\\">Keep-Alive</code>와 세션 재개 기능을 활용함</li>\\n<li><code class=\\"language-text\\">Keep-Alive</code> : 세션이 지속되므로, 최초 요청 이후 통신은 RTT가 1</li>\\n<li><strong>세션 재개 기능</strong> : 최초의 핸드셰이크에서 전에 사용하던 세션 ID를 보내면 이후 키 교환이 생략됨\\n_ = 1RTT로 세션이 재개됨\\n_ <strong>TLS 1.3</strong> : 사전에 키를 공유해 둠으로써 0RTT로 최초 요청부터 정보 전송 가능</li>\\n</ul>\\n<h3>📍 암호화 스위트</h3>\\n<p>키 교환, 메시지 암호화, 서명 등에서 사용하는 <strong>알고리즘 조합(=암호화 스위트)</strong>을 리스트화해 관리하고 서버/클라이언트에서 공통으로 사용할 수 있는 것을 선택하는 시스템을 만들어, 새로운 알고리즘을 조금씩 도입하거나 낡은 알고리즘을 비추천하는 작업</p>\\n<h3>📍 프로토콜 선택</h3>\\n<p>애플리케이션 계층 프로토콜을 선택하는 확장 기능</p>\\n<h4>☑️ ALPN(Application-Layer Protocol Negotiation)</h4>\\n<ul>\\n<li>최초 핸드셰이크 시 클라이언트가(<code class=\\"language-text\\">ClientHello</code>) 서버에 ‘클라이언트가 이용 가능한 프로토콜 목록’을 전달</li>\\n<li>서버는 응답(<code class=\\"language-text\\">ServerHello</code>)으로 키 교환하고, 인증서와 함께 프로토콜 전달</li>\\n<li>선택 가능한 목록은 IANA에서 관리 (주로 HTTP 계열, WebRTC 계열 프로토콜)</li>\\n</ul>\\n<h2>💻 Gatsby Starter에서 <code class=\\"language-text\\">develop</code> 커맨드 오류</h2>\\n<p><img src=\\"0CFB3B35-01C7-4497-81FE-68D48998F626.png\\">\\n<a href=\\"https://github.com/gatsbyjs/gatsby/issues/17557#issuecomment-531518940\\">Webpack error #98123 when running “gatsby develop” · Issue #17557 · gatsbyjs/gatsby · GitHub</a></p>\\n<h3>📍 해결 방법</h3>\\n<ol>\\n<li><code class=\\"language-text\\">package-lock.json</code>이나 <code class=\\"language-text\\">yarn.lock</code>을 삭제한다.</li>\\n<li><code class=\\"language-text\\">gatsby clean</code>으로 <code class=\\"language-text\\">.cache</code> 폴더를 지운다.</li>\\n<li><code class=\\"language-text\\">node_modules</code> 폴더를 지운다.</li>\\n<li><code class=\\"language-text\\">npm</code>이나 <code class=\\"language-text\\">yarn</code>으로 디펜던시를 다시 설치한다.</li>\\n<li><code class=\\"language-text\\">gatsby develop</code> 명령을 실행한다.</li>\\n</ol>\\n<h2>📔 개발자의 글쓰기</h2>\\n<h3>📍 문장과 단락을 구조화 하는 법</h3>\\n<ul>\\n<li>주어를 문장의 처음으로 뺀다.</li>\\n<li>문장을 쉽게 쓰려면 <strong>간단한 문장 구조로 핵심만</strong> 말한 뒤, 필요에 따라 부가 설명을 덧붙인다.</li>\\n<li>첫 문장의 주어를 소제목으로 만들면 문단 구성이 자연스러움</li>\\n<li><strong>위계(위치와 계층)</strong> : 급이 낮은 문장은 들여쓰기해서 위치를 낮춘다.</li>\\n</ul>\\n<h4>☑️ 생각을 글로 표현하는 세 가지 방법</h4>\\n<ul>\\n<li><strong>서술식</strong> : “~다.”로 끝나는 완전한 문장으로 구성된 글, 줄거리가 있는 경우</li>\\n<li><strong>개조식</strong> : 명사나 용언의 명사형(~했음)으로 끝나는 글, 항목이 반복되거나 강조가 필요한 경우 * 글머리 기호(네모, 동그라미, 숫자, 화살표 등) 사용을 권장</li>\\n<li><strong>도식</strong> : 사물 구조나 관계, 상태를 그림/서식으로 보여주는 것, 항목의 관계를 명확히 규정하고 싶은 경우</li>\\n</ul>\\n<h3>📍 띄어쓰기와 문장부호</h3>\\n<ul>\\n<li>조사, 순서, 숫자, 하다, 기호만 붙이고 나머지는 띄어 쓴다.</li>\\n</ul>\\n<h3>📍 영어 단어 선택과 외래어 표기법</h3>\\n<ul>\\n<li><strong>정확한 반대말 사용</strong> : <code class=\\"language-text\\">show</code> 다음에 <code class=\\"language-text\\">hide</code> 대신 <code class=\\"language-text\\">invisible</code> 쓰지 말라.</li>\\n</ul>\\n<h4>☑️ 중단의 의미를 가진 영어 단어</h4>\\n<ul>\\n<li><code class=\\"language-text\\">stop</code> : 잠시 중단하는 것, 언제든 재시작 가능</li>\\n<li><code class=\\"language-text\\">end</code> : 재시작할 가능성이 전혀 없음</li>\\n<li><code class=\\"language-text\\">finish</code> : 끝장을 본 상태여서 재시작을 고려할 필요도 없음</li>\\n<li><code class=\\"language-text\\">pause</code> : 잠시 일시적으로 중단된 것, 금방이라도 다시 시작할 것 같은 상황</li>\\n<li><code class=\\"language-text\\">suspend</code> : 다음 단계의 시작을 중단한 것</li>\\n<li><code class=\\"language-text\\">hold</code> : 어떤 의도가 있어서 중단한 것</li>\\n</ul>\\n<h4>☑️ 값 가져오기와 관련된 영어 단어</h4>\\n<ul>\\n<li><code class=\\"language-text\\">get</code> : 어떤 값을 반환하는 함수에 주로 사용</li>\\n<li><code class=\\"language-text\\">return</code> : 함수 내의 제어에 사용되므로 이름에 안씀</li>\\n<li><code class=\\"language-text\\">retrive</code> : 검색해서 돌려주는 것, 검색의 의미가 더 강할 때</li>\\n<li><code class=\\"language-text\\">acquire</code> : 다른 함수가 가져가지 못하게 독점하는 경우</li>\\n<li><code class=\\"language-text\\">fetch</code> : 값을 가리키는 포인터가 다음 값으로 이동한 것을 가져오는 경우</li>\\n</ul>\\n<h4>☑️ 값 저장과 관련된 영어 단어</h4>\\n<ul>\\n<li><code class=\\"language-text\\">set</code> : 값을 변경하거나 설정하는 함수에 사용</li>\\n<li><code class=\\"language-text\\">init</code> : 초기화 설정의 경우</li>\\n<li><code class=\\"language-text\\">create</code> : 정해진 틀이 없어, 틀을 생성하는 경우</li>\\n<li><code class=\\"language-text\\">register</code> : 이미 정해진 틀에 값을 집어넣는 것</li>\\n</ul>\\n<h4>☑️ 수정과 연관된 영어 단어</h4>\\n<ul>\\n<li><code class=\\"language-text\\">change</code> : 단순 내용 변경</li>\\n<li><code class=\\"language-text\\">modify</code> : 잘못된 것을 바로잡을 때</li>\\n<li><code class=\\"language-text\\">revise</code> : 새로운 정보, 아이디어를 덧붙여 달라졌음을 명시할 때</li>\\n</ul>\\n<h4>☑️ 그 외</h4>\\n<ul>\\n<li><code class=\\"language-text\\">must</code> : 필수 요구 사항</li>\\n<li><code class=\\"language-text\\">must not</code> : 절대 일어나면 안되는 사항</li>\\n<li><code class=\\"language-text\\">should</code> : 권장 사항</li>\\n<li><code class=\\"language-text\\">should not</code> : 구현되지 않는 것이 좋은 사항</li>\\n<li>정확한 단어를 쓰는 것도 중요하지만, <strong>일관성 있고 개연성 있게</strong> 사용하는 것은 더 중요</li>\\n</ul>\\n<hr>\\n<h2>👻 Today..</h2>\\n<p>암호화랑 관련된 부분을 공부했더니 머리가 아프긴 하다. 그래도 책에서 말했던 것처럼 깊게 들어가기보다는 전반적인 과정을 짚어줘서 확실히 도움이 많이 되고 용어나 전체 과정을 이해할 수 있는 부분이 좋았던 것 같다. 수준에 잘 맞는 책을 고른 것 같아서 다행.</p>\\n<p>그리고 스터디 책으로 샀던 “개발자의 글쓰기\\" 라는 책을 이제 읽고 있는데, 생각보다 술술 읽히고 재밌다. 지금까지 읽은 내용만으로 평가하자면 재미있게 잘 쓰시는 것 같다. 때 아닌 백수가 되어서 책도 여유롭게 읽고 최고다. 👻</p>","frontmatter":{"subject":["Keep-Alive","Pipelining","TLS"],"date":"2020-03-16"}}},{"node":{"html":"<h2>🌏 미디어쿼리 <code class=\\"language-text\\">@media</code></h2>\\n<p>출력 장치의 여러 특징 가운데 일부를 참조하여 CSS 코드를 분기 처리함으로써 하나의 HTML 소스가 여러 가지 뷰를 갖도록 구현할 수 있는 명세</p>\\n<h3>📍 CSS 코드 내부에서 분기하는 방법</h3>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">@media only all and (조건문) {실행문}</code></pre></div>\\n<ul>\\n<li><code class=\\"language-text\\">only</code> : 미디어 쿼리를 지원하는 사용자 에이전트만 미디어 쿼리 구문을 해석하라는 명령어 (생략 가능, 기본 값)</li>\\n<li><code class=\\"language-text\\">not</code> : 뒤에 오는 모든 조건을 부정하는 연산</li>\\n<li><code class=\\"language-text\\">all</code> : 모든 미디어가 구문을 해석해야 함 (생략 가능, 기본 값) * 특정 미디어 : <code class=\\"language-text\\">aural</code>, <code class=\\"language-text\\">braille</code>, <code class=\\"language-text\\">embossed</code>, <code class=\\"language-text\\">handheld</code>, <code class=\\"language-text\\">print</code>, <code class=\\"language-text\\">projection</code>, <code class=\\"language-text\\">screen</code>, <code class=\\"language-text\\">speech</code>, <code class=\\"language-text\\">tty</code>, <code class=\\"language-text\\">tv</code></li>\\n<li><code class=\\"language-text\\">and</code> : 앞과 뒤의 조건을 모두 만족해야 함을 나타내는 연산자</li>\\n<li><code class=\\"language-text\\">,</code> : OR 연산을 수행 (조건 중 하나만 참이어도 실행문 해석)</li>\\n</ul>\\n<h3>📍 CSS 코드 외부에서 분기하는 방법</h3>\\n<div class=\\"gatsby-highlight\\" data-language=\\"html\\"><pre class=\\"language-html\\"><code class=\\"language-html\\"><span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;</span>link</span> <span class=\\"token attr-name\\">rel</span><span class=\\"token attr-value\\"><span class=\\"token punctuation\\">=</span><span class=\\"token punctuation\\">\\"</span>stylesheet<span class=\\"token punctuation\\">\\"</span></span> <span class=\\"token attr-name\\">type</span><span class=\\"token attr-value\\"><span class=\\"token punctuation\\">=</span><span class=\\"token punctuation\\">\\"</span>text/css<span class=\\"token punctuation\\">\\"</span></span> <span class=\\"token attr-name\\">media</span><span class=\\"token attr-value\\"><span class=\\"token punctuation\\">=</span><span class=\\"token punctuation\\">\\"</span>all and (조건 A)<span class=\\"token punctuation\\">\\"</span></span> <span class=\\"token attr-name\\">href</span><span class=\\"token attr-value\\"><span class=\\"token punctuation\\">=</span><span class=\\"token punctuation\\">\\"</span>A.css<span class=\\"token punctuation\\">\\"</span></span> <span class=\\"token punctuation\\">/></span></span>\\n<span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;</span>link</span> <span class=\\"token attr-name\\">rel</span><span class=\\"token attr-value\\"><span class=\\"token punctuation\\">=</span><span class=\\"token punctuation\\">\\"</span>stylesheet<span class=\\"token punctuation\\">\\"</span></span> <span class=\\"token attr-name\\">type</span><span class=\\"token attr-value\\"><span class=\\"token punctuation\\">=</span><span class=\\"token punctuation\\">\\"</span>text/css<span class=\\"token punctuation\\">\\"</span></span> <span class=\\"token attr-name\\">media</span><span class=\\"token attr-value\\"><span class=\\"token punctuation\\">=</span><span class=\\"token punctuation\\">\\"</span>all and (조건 B)<span class=\\"token punctuation\\">\\"</span></span> <span class=\\"token attr-name\\">href</span><span class=\\"token attr-value\\"><span class=\\"token punctuation\\">=</span><span class=\\"token punctuation\\">\\"</span>B.css<span class=\\"token punctuation\\">\\"</span></span> <span class=\\"token punctuation\\">/></span></span></code></pre></div>\\n<ul>\\n<li>브라우저 사용자가 언제든 조건을 변경(ex: 창 크기 변경) 할 수 있기 때문에 두 파일을 항상 요청함</li>\\n<li>불필요하게 <strong>요청을 두 번 발생</strong>하기 때문에, 성능 저하의 원인이 되므로 <strong>코드 내부에서 분기하는 방법을 권장</strong></li>\\n</ul>\\n<h3>📍 미디어 쿼리 코드 템플릿</h3>\\n<p>모든 해상도를 커버하기 위한 미디어 쿼리 코드 템플릿</p>\\n<div class=\\"gatsby-highlight\\" data-language=\\"css\\"><pre class=\\"language-css\\"><code class=\\"language-css\\"><span class=\\"token atrule\\"><span class=\\"token rule\\">@charset</span> <span class=\\"token string\\">\\"utf-8\\"</span><span class=\\"token punctuation\\">;</span></span>\\n\\n<span class=\\"token comment\\">/* All Device */</span>\\n모든 해상도를 위한 공통 코드\\n\\n<span class=\\"token comment\\">/* Mobile Device */</span>\\n768px 미만 해상도의 모바일 기기를 위한 코드\\n\\n<span class=\\"token comment\\">/* Tablet, Desktop Device */</span>\\n<span class=\\"token atrule\\"><span class=\\"token rule\\">@media</span> all and <span class=\\"token punctuation\\">(</span><span class=\\"token property\\">min-width</span><span class=\\"token punctuation\\">:</span> 768px<span class=\\"token punctuation\\">)</span></span> <span class=\\"token punctuation\\">{</span>\\n  해상도 768px 이상일 때 실행됨<span class=\\"token punctuation\\">,</span> 태블릿 데스크탑 공통 코드\\n<span class=\\"token punctuation\\">}</span>\\n\\n<span class=\\"token atrule\\"><span class=\\"token rule\\">@media</span> all and <span class=\\"token punctuation\\">(</span><span class=\\"token property\\">min-width</span><span class=\\"token punctuation\\">:</span> 768px<span class=\\"token punctuation\\">)</span> and <span class=\\"token punctuation\\">(</span><span class=\\"token property\\">max-width</span><span class=\\"token punctuation\\">:</span> 1024px<span class=\\"token punctuation\\">)</span></span> <span class=\\"token punctuation\\">{</span>\\n  해상도가 768px 이상이고 1024px 이하일 때 실행됨\\n<span class=\\"token punctuation\\">}</span>\\n\\n<span class=\\"token atrule\\"><span class=\\"token rule\\">@media</span> all and <span class=\\"token punctuation\\">(</span><span class=\\"token property\\">min-width</span><span class=\\"token punctuation\\">:</span> 1025px<span class=\\"token punctuation\\">)</span></span> <span class=\\"token punctuation\\">{</span>\\n  해상도 1025px 이상일 때 실행됨<span class=\\"token punctuation\\">,</span> 랩탑 또는 데스크톱용 코드\\n<span class=\\"token punctuation\\">}</span></code></pre></div>\\n<ul>\\n<li><code class=\\"language-text\\">width</code>, <code class=\\"language-text\\">height</code> : 뷰포트(HTML body 컨텐츠 영역의 크기)의 너비와 높이, 가장 일반적으로 사용하는 조건</li>\\n<li><code class=\\"language-text\\">device-width</code>, <code class=\\"language-text\\">device-height</code> : 스크린(출력 장치가 픽셀을 표시할 수 있는 모든 영역)의 너비와 높이</li>\\n<li><code class=\\"language-text\\">orientation</code> : 뷰포트의 너비와 높이 비율을 이용해 가로/세로 모드를 판단 * <strong>value</strong> : <code class=\\"language-text\\">portrait</code>(세로모드), <code class=\\"language-text\\">landscape</code>(가로모드)</li>\\n<li><code class=\\"language-text\\">aspect-ratio</code> : 뷰포트의 너비와 높이에 대한 비율, <code class=\\"language-text\\">min/max</code> 접두사로 최소/최대 비율 설정 가능</li>\\n<li><code class=\\"language-text\\">device-aspect-ratio</code> : 스크린의 너비와 높이에 대한 비율, <code class=\\"language-text\\">min/max</code> 접두사로 최소/최대 비율 설정 가능</li>\\n<li><code class=\\"language-text\\">color</code> : 출력 장치의 색상에 대한 비트 수</li>\\n</ul>\\n<blockquote>\\n<p><strong>Ref</strong> : <a href=\\"https://naradesign.github.io/article/media-query.html\\">CSS3 미디어쿼리 @media 규칙 이해. | article</a></p>\\n</blockquote>\\n<hr>\\n<h2>👻 Today..</h2>\\n<p>아이패드 열었는데, CSS 관련 검색한 페이지에서 미디어 종류라는 키워드를 보고 뜬금없이 미디어쿼리에 대해서 검색해보게 됐다. 덕분에 코드 템플릿도 찾고 기타 옵션도 알게 되어서 좋은 것 같다.</p>","frontmatter":{"subject":["media query"],"date":"2020-03-14"}}},{"node":{"html":"<h2>🌏 캐시</h2>\\n<ul>\\n<li>데이터를 임시로 저장해두는 물리적/논리적 장치</li>\\n<li><strong>캐싱</strong> : 이러한 일련의 과정을 통해 컴퓨터 혹은 시스템의 성능을 향상시키는 작업</li>\\n</ul>\\n<h3>📍 캐시의 종류</h3>\\n<p>캐시 메모리, 웹 브라우저 캐시, DNS 캐시, 웹 캐시 등</p>\\n<ul>\\n<li><strong>캐시 메모리</strong> : CPU와 메모리 속도 차이를 줄여주어서 컴퓨터 처리 성능을 높이는 장치</li>\\n<li><strong>웹 브라우저 캐시</strong> : 최근 다운로드 한 파일을 하드디스크에 저장해 둠으로써, 데이터 중복 다운로드를 줄여서 전송 지연을 줄여줌</li>\\n<li><strong>DNS 캐시</strong> : 도메인 네임 서버에서 한 번 질의된 도메인 네임과 해당 IP 주소를 캐시에 유지</li>\\n<li><strong>웹 캐시(프록시 캐시)</strong> : 웹 서버 주변의 프록시 서버에 캐시를 두어 서버의 부하를 감소시키고 대역폭을 절약함</li>\\n<li><strong>디스크 캐시</strong> : 빠른 접근 속도를 위해 RAM의 여분 장소 또는 특수한 하드디스크 캐시에 최근 사용한 데이터와 곧 사용하게 될 것으로 예견되는 주변의 데이터 사본을 저장</li>\\n<li>RAM : 하드디스크에서 메모리로 적재된 데이터를 이용하는 것도 일종의 캐시라고 할 수 있음</li>\\n</ul>\\n<blockquote>\\n<p><strong>Ref</strong> : <a href=\\"https://m.blog.naver.com/PostView.nhn?blogId=phkaa&#x26;logNo=134703237&#x26;proxyReferer=https%3A%2F%2Fwww.google.com%2F\\">Cache Server 이해 : 네이버 블로그</a></p>\\n</blockquote>\\n<h2>🌏 프록시(Proxy)</h2>\\n<p>클라이언트로부터 받은 요청을 서버로 전달하고, 서버에서 받은 응답을 클라이언트로 전달하는 역할</p>\\n<ul>\\n<li>🔎 클라이언트에서 서버로 가는 경로에 여러 대의 프록시를 거친다면, 요청 헤더에 어떤 프록시를 거쳐가는지 명시해야 함</li>\\n</ul>\\n<h3>📍 프록시의 사용 목적</h3>\\n<p>네트워크 캐싱, 조직 내의 특정 웹사이트 액세스 방지, 액세스 로그 획득 등</p>\\n<ul>\\n<li><strong>Caching Proxy</strong> : 서버의 응답을 프록시 서버에 보존해두고, 이전과 같은 요청이 들어오면 서버를 거치지 않고 바로 캐싱해둔 응답을 돌려주는 것</li>\\n<li><strong>Transparent Proxy</strong> : 클라이언트와 서버를 중계하면서 메세지 변경을 하지 않는 프록시</li>\\n</ul>\\n<blockquote>\\n<p><strong>Ref</strong> : <a href=\\"https://rhammer.tistory.com/245\\">HTTP 웹서버와 HTTP. (프록시, 게이트웨이, 가상호스트) :: 고무망치의 Dev N Life</a></p>\\n</blockquote>\\n<h2>🌏 게이트웨이(Gateway)</h2>\\n<p>두 컴퓨터가 네트워크 상에서 서로 연결되려면 동일한 프로토콜을 사용해야 하는데, 게이트웨이가 서로 다른 프로토콜의 네트워크를 적절한 프로토콜로 변환해주는 역할을 함 <a href=\\"https://brownbears.tistory.com/195\\">[참고]</a></p>\\n<h2>📔 리얼월드 HTTP - 2.9 Referer</h2>\\n<p>어느 경로로 웹사이트에 도달했는지 서버가 파악할 수 있도록 클라이언트가 서버에 보내는 헤더</p>\\n<blockquote>\\n<p>철자가 영어 <code class=\\"language-text\\">referrer</code>와 다른 이유는 <strong>RFC 1945</strong>의 오타가 그대로 남은 것이라고 함</p>\\n</blockquote>\\n<ul>\\n<li><strong>어떤 페이지에서 링크를 클릭해서 다른 사이트로 이동할 때</strong> : 페이지의 링크가 전달됨</li>\\n<li><strong>웹 페이지가 이미지, 스크립트를 가져올 때</strong> : 리소스를 이용하는 HTML 파일의 주소가 전달됨</li>\\n<li><strong>북마크에서 선택하거나 주소창에서 키보드로 입력했을 때</strong> : <code class=\\"language-text\\">Referer</code> 헤더를 전송하지 않거나 <code class=\\"language-text\\">Referer: about: blank</code>를 전송</li>\\n</ul>\\n<blockquote>\\n<p>검색 엔진에서 검색 결과를 <code class=\\"language-text\\">?q=키워드</code> 형식의 URL로 표시할 때, 이 URL을 리퍼러로 전달하면, 서버 측에서는 어떤 키워드로 접근했는지 알 수 있음</p>\\n</blockquote>\\n<h3>📍 리퍼러 정책</h3>\\n<blockquote>\\n<p>여기에선 철자 오류 수정됨</p>\\n</blockquote>\\n<ul>\\n<li><strong><code class=\\"language-text\\">Referrer-Policy</code> 헤더</strong> : 각 요청에 대한 설정</li>\\n<li><strong><code class=\\"language-text\\">&lt;meta name=“referrer” content=“설정값”&gt;</code></strong> : 해당 페이지에 대한 설정</li>\\n<li><strong><code class=\\"language-text\\">&lt;a&gt;</code> 태그 등의 <code class=\\"language-text\\">referrerpolicy</code> 속성 및 <code class=\\"language-text\\">rel=“noreferrer”</code> 속성</strong> : 각 링크에 대한 설정</li>\\n</ul>\\n<h4>☑️ 리퍼러 정책으로 설정할 수 있는 값</h4>\\n<ul>\\n<li><code class=\\"language-text\\">no-referrer</code> : 전혀 보내지 않는다</li>\\n<li><code class=\\"language-text\\">no-reffer-when-downgrade</code> : (기본 동작과 마찬가지로) HTTPS -> HTTP 일 때는 전송하지 않음</li>\\n<li><code class=\\"language-text\\">same-origin</code> : 동일 도메인 내의 링크에 대해서만 리퍼러를 전송</li>\\n<li><code class=\\"language-text\\">origin</code> : 상세 페이지가 아니라 톱페이지에서 링크된 것으로 보이도록 도메인 이름만 전송</li>\\n<li><code class=\\"language-text\\">strict-origin</code> : <code class=\\"language-text\\">origin</code>과 같지만, HTTPS -> HTTP는 전송하지 않음</li>\\n<li><code class=\\"language-text\\">origin-when-crossorigin</code> : 같은 도매인 내에서는 완전 리퍼러를, 다른 도메인에는 도메인 이름만 전송</li>\\n<li><code class=\\"language-text\\">strict-origin-when-crossorigin</code> : <code class=\\"language-text\\">origin-when-crossorigin</code>과 같지만, HTTPS -> HTTP는 전송하지 않음</li>\\n<li><code class=\\"language-text\\">unsafe-url</code> : 항상 전송</li>\\n</ul>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">Content-Security-Policy: referrer origin</code></pre></div>\\n<p><code class=\\"language-text\\">Content-Security-Policy</code> 헤더는 많은 보안 설정을 한꺼번에 변경할 수 있음</p>\\n<h2>📔 리얼월드 HTTP - 2.10 검색 엔진용 컨텐츠 접근 제어</h2>\\n<p>봇(자동 순회 프로그램, 크롤링 용도로 주로 사용됨)의 접근을 막기 위해 <code class=\\"language-text\\">robots.txt</code>, 사이트맵의 방법을 사용</p>\\n<h3>📍 robots.txt</h3>\\n<p>서버 컨텐츠 제공자가 크롤러에 접근 허가 여부를 전하기 위한 프로토콜로, 읽기를 금지할 크롤러의 이름과 장소를 지정</p>\\n<blockquote>\\n<p>저작권 침해 소송에서 근거로 사용되었음. <code class=\\"language-text\\">robots.txt</code>를 설치하면 서비스 제공자가 명확히 의사를 표명한 것으로 봐야 하므로 안지키면 소송당할 수 있음.</p>\\n</blockquote>\\n<h4>☑️ robots.txt에 지정하는 방법</h4>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">User-agent: *\\nDisallow: /cgi-bin/\\nDisallow: /tmp/</code></pre></div>\\n<ul>\\n<li>모든 크롤러에 대해 <code class=\\"language-text\\">/cgi-bin</code>과 <code class=\\"language-text\\">/tmp</code> 접근을 금지</li>\\n<li><code class=\\"language-text\\">User-agent</code>에 구글 봇처럼 개별적으로 지정할 수 있음</li>\\n</ul>\\n<h4>☑️ HTML의 메타 태그로 지정하는 방법</h4>\\n<div class=\\"gatsby-highlight\\" data-language=\\"html\\"><pre class=\\"language-html\\"><code class=\\"language-html\\"><span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;</span>meta</span> <span class=\\"token attr-name\\">name</span><span class=\\"token attr-value\\"><span class=\\"token punctuation\\">=</span><span class=\\"token punctuation\\">\\"</span>robots<span class=\\"token punctuation\\">\\"</span></span> <span class=\\"token attr-name\\">content</span><span class=\\"token attr-value\\"><span class=\\"token punctuation\\">=</span><span class=\\"token punctuation\\">\\"</span>noindex<span class=\\"token punctuation\\">\\"</span></span> <span class=\\"token punctuation\\">/></span></span></code></pre></div>\\n<ul>\\n<li><code class=\\"language-text\\">noindex</code> : 검색엔진이 인덱스 하는 것을 거부</li>\\n<li><code class=\\"language-text\\">nofollow</code> : 크롤러가 페이지 내의 링크를 따라가는 것을 거부</li>\\n<li><code class=\\"language-text\\">noarchive</code> : 페이지 내 컨텐츠를 캐시하는 것을 거부</li>\\n</ul>\\n<h4>☑️ 헤더에 지정하는 방법</h4>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">X-Robots-Tag: noindex, nofollow</code></pre></div>\\n<h3>📍 사이트맵</h3>\\n<p>웹 사이트에 포함된 페이지 목록과 메타데이터를 제공하는 XML 파일, 화이트리스트처럼 사용됨</p>\\n<blockquote>\\n<p>자바스크립트로 만들어진, 플래시로 만들어진 동적 페이지의 링크처럼 크롤러가 찾을 수 없는 경우 사이트맵으로 보완할 수 있음</p>\\n</blockquote>\\n<div class=\\"gatsby-highlight\\" data-language=\\"xml\\"><pre class=\\"language-xml\\"><code class=\\"language-xml\\"><span class=\\"token prolog\\">&lt;?xml version=\\"1.0\\" encoding=\\"utf-8\\" ?></span>\\n<span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;</span>urlset</span> <span class=\\"token attr-name\\">xmlns</span><span class=\\"token attr-value\\"><span class=\\"token punctuation\\">=</span><span class=\\"token punctuation\\">\\"</span>http://www.sitemaps.org/schemas/sitemap/0.9<span class=\\"token punctuation\\">\\"</span></span>\\n\\t<span class=\\"token attr-name\\"><span class=\\"token namespace\\">xmlns:</span>xsi</span><span class=\\"token attr-value\\"><span class=\\"token punctuation\\">=</span><span class=\\"token punctuation\\">\\"</span>http://www.w3.org/2001/XMLSchema-instance<span class=\\"token punctuation\\">\\"</span></span>\\n\\t<span class=\\"token attr-name\\"><span class=\\"token namespace\\">xsi:</span>schemaLocation</span><span class=\\"token attr-value\\"><span class=\\"token punctuation\\">=</span><span class=\\"token punctuation\\">\\"</span>http://www.sitemaps.org/schemas/sitemap/0.9\\n\\t\\thttp://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd<span class=\\"token punctuation\\">\\"</span></span><span class=\\"token punctuation\\">></span></span>\\n\\t<span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;</span>url</span><span class=\\"token punctuation\\">></span></span>\\n\\t\\t<span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;</span>loc</span><span class=\\"token punctuation\\">></span></span>http://example.com<span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;/</span>loc</span><span class=\\"token punctuation\\">></span></span>\\n\\t\\t<span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;</span>lastmod</span><span class=\\"token punctuation\\">></span></span>2006-11-18<span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;/</span>lastmod</span><span class=\\"token punctuation\\">></span></span>\\n\\t<span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;/</span>url</span><span class=\\"token punctuation\\">></span></span>\\n<span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;/</span>urlset</span><span class=\\"token punctuation\\">></span></span></code></pre></div>\\n<ul>\\n<li>등록하고 싶은 페이지 수만큼 <code class=\\"language-text\\">&lt;url&gt;</code> 태그를 작성</li>\\n<li><code class=\\"language-text\\">&lt;loc&gt;</code> : 절대 URL</li>\\n<li>텍스트 파일, RSS, 아톰 등의 형식도 사이트맵에 이용할 수 있음</li>\\n<li>구글의 경우 사이트맵으로 웹사이트 메타데이터를 검색 엔진에 전달할 수 있음</li>\\n</ul>\\n<hr>\\n<h2>👻 Today..</h2>\\n<p><code class=\\"language-text\\">robots.txt</code>는 예전에 찾아본 적이 있어서 알고 있었는데, 사이트맵에 대해서는 제대로 첨 찾아봤다. 블로그 만들 때, 검색엔진에 노출되려면 어떤 태그를 페이지에 넣고 뭘 만들고 했던 거 같은데 어떻게 되는지 찾아봐야겠다.</p>\\n<blockquote>\\n<p>내 블로그도 빌드하면 결과물에 <a href=\\"https://github.com/devSoyoung/devsoyoung.github.io/blob/master/sitemap.xml\\">sitemap.xml</a> 파일이 생기고, url 태그 목록으로 나와있다. 이걸 이제 알았네 😝</p>\\n</blockquote>","frontmatter":{"subject":["cache","gateway","robots.txt","sitemap","Referer"],"date":"2020-03-13"}}},{"node":{"html":"<h2>⚙️ 개발 환경 설정</h2>\\n<p>어제 노트북을 초기화해서 개발환경을 새로 세팅하는 중</p>\\n<ul>\\n<li><code class=\\"language-text\\">zsh</code> : shell을 보다 더 편리하게 사용할 수 있도록 여러 기능을 제공</li>\\n<li><code class=\\"language-text\\">oh-my-zsh</code> : zsh 설정을 관리하기 위한 프레임워크, 여러 플러그인 사용 가능</li>\\n<li><strong>git 설치</strong> : Xcode 설치되어 있을 때, git 커맨드 최초 실행하면 설치할지 물어보는 메세지가 뜬다.</li>\\n</ul>\\n<h2>📔 리얼월드 HTTP - 2.7 프록시</h2>\\n<ul>\\n<li>HTTP 등의 통신을 중계, 각종 부가 기능을 구현</li>\\n<li>외부 공격으로부터 네트워크를 보호하는 방화벽 역할</li>\\n<li>저속 통신 회선용으로 데이터를 압축해 속도를 높이는 필터, 컨텐츠 필터링에 사용</li>\\n<li>프록시 서버가 악용되지 않도록 인증을 이용해 보호하는 경우, <code class=\\"language-text\\">Proxy-Authenticate</code> 헤더에 인증 방식에 맞는 값을 추가함</li>\\n<li><code class=\\"language-text\\">X-Forwarded-For</code> : 중계 프록시의 경우, 중간의 호스트 IP 주소를 이 헤더에 기록\\n_ 기존에 사실상의 표준으로 사용되다, 2014년 RFC 7239로 표준화 됨\\n_ 예시) X-Forwarded-For : client, proxy1, proxy2</li>\\n</ul>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">$ curl --http1.0 -x http://localhost:18888 -U user:pass http://example.com/helloworld</code></pre></div>\\n<ul>\\n<li><code class=\\"language-text\\">-U/--proxy-user</code> : 프록시 인증용 유저 정보🔑, 아이디:패스워드</li>\\n<li><code class=\\"language-text\\">—proxy-basic</code>, <code class=\\"language-text\\">—proxy-digest</code> : 프록시 인증 방식 변경</li>\\n</ul>\\n<h3>📍 프록시와 게이트웨이</h3>\\n<ul>\\n<li><strong>프록시</strong> : 통신 내용을 이해하고, 필요에 따라 컨텐츠를 수정하거나 서버 대신 응답</li>\\n<li><strong>게이트웨이</strong> : 통신 내용을 그대로 전송하고, 클라이언트는 중간에 게이트웨이의 존재를 몰라야 함</li>\\n</ul>\\n<h2>📔 리얼월드 HTTP - 2.8 캐시</h2>\\n<p>컨텐츠가 변경되지 않았을 때, 로컬에 저장된 파일을 재사용함으로써 다운로드 횟수를 줄이고 성능을 높이는 방법</p>\\n<h3>📍 갱신 일자에 따른 캐시</h3>\\n<p><code class=\\"language-text\\">If-Modified-Since</code>에 서버에서 반환된 일시를 전달하면, 이 값과 서버의 콘텐츠 일시를 비교</p>\\n<ul>\\n<li><strong>변경되었을 경우</strong> : 컨텐츠를 바디에 전달</li>\\n<li><strong>아닐 경우</strong> : <code class=\\"language-text\\">304 Not Modified</code>를 반환</li>\\n</ul>\\n<h3>📍 Expires</h3>\\n<p>(갱신 일시 방법은 캐시 유효성 검사를 위해 통신이 발생하기 때문에) 통신 없이 <strong>지정한 기한 내일 경우 이용 가능</strong>한 것으로 판단</p>\\n<ul>\\n<li>3초 후 컨텐츠 유효 기간이 끝난다고 설정해도, 리로드 하지 않고 접속을 할지 말지 판단할 때만 사용</li>\\n<li>뒤로 가기 등으로 방문 이력을 조작하는 경우, 기한 지난 컨텐츠 그대로 사용될 수 있음</li>\\n<li>서버에 변경사항을 묻지 않으므로, SNS 톱페이지 등에 사용할 때 주의해야 함</li>\\n<li>스타일시트 등 자주 갱신되지 않는 정적 컨텐츠에 사용하는 것이 바람직함</li>\\n</ul>\\n<h3>📍 <code class=\\"language-text\\">Pragma: no-cache</code></h3>\\n<p>요청한 컨텐츠가 이미 저장되어 있어도, 원래 서버(오리진 서버)에서 가져오도록 지시</p>\\n<ul>\\n<li><code class=\\"language-text\\">Cache-Control</code>로 통합되었지만, 1.1 이후에도 하위 호환성 유지를 위해 남아있음</li>\\n<li>REST는 ‘클라이언트가 컨텐츠의 의미 등을 사전 지식으로 갖지 않는 것’을 목표로 하기 때문에, 이런 방식의 사용을 권장하지는 않음</li>\\n<li>프록시가 중간에서 하나라도 <code class=\\"language-text\\">no-cache</code>를 무시하면 기대한 대로 동작하지 않기 때문에, 보증할 수 없음</li>\\n<li>HTTP2 이후 보안 접속 비율이 증가했기 때문에, 프록시가 통신 내용을 감지하지 못하고 중계만 하므로 프록시 캐시를 외부에서 적극 관리하는 의미가 없음</li>\\n</ul>\\n<h3>📍 ETag 추가</h3>\\n<p>여러 가지 정보를 조합해서 유효성을 판단하는 값 지정하는 방법</p>\\n<ol>\\n<li>최초 요청 시, 서버는 응답에 <code class=\\"language-text\\">ETag</code> 헤더를 부여</li>\\n<li>이후 다운로드 시 클라이언트는 <code class=\\"language-text\\">If-None-Match</code> 헤더에 (1)에서 받은 <code class=\\"language-text\\">ETag</code> 값을 추가해서 요청</li>\\n<li>서버에서 보내려는 파일의 <code class=\\"language-text\\">ETag</code>와 비교해 같으면 <code class=\\"language-text\\">304 Not Modified</code>로 응답</li>\\n</ol>\\n<p><code class=\\"language-text\\">ETag</code> 값은 서버가 자유롭게 결정해서 반환할 수 있음</p>\\n<ul>\\n<li>생성일시 외에도 갱신 정보를 고려한 해시 값을 서버가 생성할 수 있음</li>\\n<li><strong>일부 웹서버(nginx, h2o)</strong> : <code class=\\"language-text\\">갱신일시-파일크기</code> 형식 (갱신 일시의 유닉스 시간-파일 크기의 바이트를 각각 16진수로 연결)</li>\\n<li><strong>예전 아파치</strong> : 갱신 일시, 크기 이외에 inode 번호(디스크상의 컨텐츠를 나타내는 인덱스 값, 동일 드라이브 내에서 고유) 사용\\n_ 서버를 여러 대 병렬한 경우, 같은 컨텐츠인데 아이디가 달라 <code class=\\"language-text\\">ETag</code>가 달라져서 캐시 낭비 발생\\n_ 그 외에도 잠재적 공격 기회를 허용하는 문제, 자식 프로세스 ID가 멀티파트 MIME 바운더리에서 유출될 수 있는 문제(?) 수정됨</li>\\n</ul>\\n<h3>📍 Cache-Control (1) - 서버의 응답에서 사용하는 설정값</h3>\\n<p>더 유연한 캐시 제어를 지시할 수 있고, <code class=\\"language-text\\">Expires</code> 보다 우선해서 처리됨</p>\\n<blockquote>\\n<p><code class=\\"language-text\\">Cache-Control</code>은 리로드를 억제하는 시스템이며, 개인 정보 보호 목적으로 사용할 수 없음</p>\\n</blockquote>\\n<ul>\\n<li><code class=\\"language-text\\">public</code> : 같은 컴퓨터를 사용하는 복수의 사용자간 캐시 재사용을 허가</li>\\n<li><code class=\\"language-text\\">private</code> : 같은 컴퓨터를 사용하는 다른 사용자 간 캐시를 재사용하지 않음\\n_ 같은 URL에서 사용자마다 다른 컨텐츠가 돌아오는 경우, 이상한 결과가 되지 않도록 지시\\n_ 보안 접속이 아니면 통신 경로에서 내용이 보이기 때문에, 보안 목적으로 착각하면 안됨</li>\\n<li><code class=\\"language-text\\">max-age=n</code> : 캐시 신선도를 초단위로 설정(86400 : 하루동안 캐시가 유효)</li>\\n<li><code class=\\"language-text\\">s-maxage=n</code> : <code class=\\"language-text\\">max-age</code>와 같으나, 공유 캐시에 대한 설정값</li>\\n<li><code class=\\"language-text\\">no-cache</code> : 캐시가 유효한지 매번 문의 (<code class=\\"language-text\\">max-age=0</code>과 거의 같음)</li>\\n<li><code class=\\"language-text\\">no-store</code> : 캐시하지 않음 * 캐시 서버가 저장하지 않을 뿐, 캐시 서버가 통신 내용 감시를 억제하는 기능은 없음</li>\\n<li><code class=\\"language-text\\">no-transform</code> : 프록시가 컨텐츠 변경하는 것을 제어</li>\\n<li><code class=\\"language-text\\">must-revalidate</code> : <code class=\\"language-text\\">no-cache</code>와 비슷하지만, 프록시 서버에 보내는 지시가 됨 * 프록시가 서버에 문의했을 때 서버의 응답이 없으면, 프록시가 클라이언트에 <code class=\\"language-text\\">504 Gateway Timeout</code>을 반환하도록 함</li>\\n<li><code class=\\"language-text\\">proxy-revalidate</code> : <code class=\\"language-text\\">must-revalidate</code>와 같지만, 공유 캐시에만 요청</li>\\n</ul>\\n<blockquote>\\n<p><code class=\\"language-text\\">no-cache</code>는 <code class=\\"language-text\\">Pragma: no-cache</code>와 똑같이 캐시하지 않는 것은 아니고, 시간을 보고 서버에 접속하지 않은 채 컨텐츠를 재이용하는 것을 그만둠. 캐시하지 않는 것은 <code class=\\"language-text\\">no-store</code></p>\\n</blockquote>\\n<ul>\\n<li>콤마로 구분해서 복수 지정이 가능</li>\\n<li><code class=\\"language-text\\">public</code>, <code class=\\"language-text\\">private</code> 둘 중에서는 하나만 선택, 기본은 <code class=\\"language-text\\">private</code></li>\\n<li><code class=\\"language-text\\">max-age</code>, <code class=\\"language-text\\">s-maxage</code>, <code class=\\"language-text\\">no-cache</code>, <code class=\\"language-text\\">no-store</code> 중 하나</li>\\n<li>모순된 설정의 우선순위에 대한 명세는 없음 (궁금하면 직접 실험해봅시다👨🏻‍🔬)</li>\\n</ul>\\n<h3>📍 Cache-Control (2) - 클라이언트의 요청에서 사용하는 설정값</h3>\\n<ul>\\n<li><code class=\\"language-text\\">no-cache</code> : <code class=\\"language-text\\">Pragma: no-cache</code>와 같음</li>\\n<li><code class=\\"language-text\\">no-store</code> : 응답의 <code class=\\"language-text\\">no-store</code>와 같고, 프록시 서버에 캐시를 삭제하도록 요청</li>\\n<li><code class=\\"language-text\\">max-age</code> : 프록시에서 저장된 캐시가 최초로 저장되고 나서, 지정 시간 이상 캐시는 사용하지 않도록 프록시에 요청</li>\\n<li><code class=\\"language-text\\">max-satle</code> : 캐시 유지 기간이 지났어도, 지정 시간 동안 저장된 캐시 재사용 하도록 프록시에 요청 * 연장 시간은 생략할 수 있고, 그런 경우 영원히 유효하다는 의미</li>\\n<li><code class=\\"language-text\\">min-fresh</code> : 캐시 수명 남아 있을 때, 캐시 보내도 좋다고 프록시에 요청 (적어도 지정된 시간 만큼은 유효해야 함)</li>\\n<li><code class=\\"language-text\\">no-transform</code> : 프록시가 컨텐츠 변형하지 않도록 요청</li>\\n<li><code class=\\"language-text\\">only-if-cached</code> : 캐시된 경우에만 응답 반환하고, 캐시된 컨텐츠 없을 때는 <code class=\\"language-text\\">504 Gateway Timeout</code> 반환하도록 프록시에 요청 * 처음을 제외하고 오리진 서버에 전혀 액세스하지 않음 <em>(대체 언제 쓰나)</em></li>\\n</ul>\\n<h3>📍 Vary</h3>\\n<p>같은 URL이라도, 클라이언트에 따라 반환 결과가 다름을 나타내는 헤더</p>\\n<ul>\\n<li>스마트폰용 브라우저의 경우 모바일 페이지가 표시되는 경우</li>\\n<li>사용 언어에 따라 내용이 바뀌는 경우</li>\\n</ul>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">Vary: User-Agent, Accept-Language</code></pre></div>\\n<p>위와 같이 표시가 바뀌는 이유를 나열하며, 검색 엔진용 힌트로도 사용됨</p>\\n<blockquote>\\n<p>브라우저 종류에 따라 컨텐츠가 바뀌는 것은, 모바일 버전이 다르게 보인다고 판단할 수 있는 재료가 되고, 언어별로 바르게 인덱스를 만드는 힌트가 됨</p>\\n</blockquote>\\n<ul>\\n<li><code class=\\"language-text\\">User-Agent</code>로 모바일 판정 : 관례적인 것이지, 정규화 된 값은 아니고 바꿀 수도 있음</li>\\n<li><strong>2017 구글 가이드라인</strong> : 같은 컨텐츠를 모든 브라우저에 배포하고, 브라우저가 필요한 설정을 선택하도록 하는 반응형 웹 디자인을 권장</li>\\n</ul>\\n<h2>🌏 웹 캐시의 종류</h2>\\n<p>Ref : <a href=\\"https://cyberx.tistory.com/9\\">더 빠른 웹을 위하여 - 웹 캐쉬 (WEB CACHE) :: 사이버이메지네이션 블로그</a></p>\\n<h3>📍 브라우저 캐시</h3>\\n<ul>\\n<li>브라우저 또는 요청하는 클라이언트 애플리케이션에 의해 내부 디스크에 저장</li>\\n<li>캐시된 자원을 공유하지 않는 한, 개인에 한정된 Cache</li>\\n<li>브라우저의 뒤로가기 버튼이나 재방문 페이지에 효과적인 캐시</li>\\n</ul>\\n<h3>📍 프록시 캐시 (잘 이해 못함)</h3>\\n<div class=\\"gatsby-highlight\\" data-language=\\"text\\"><pre class=\\"language-text\\"><code class=\\"language-text\\">프록시 서버는 클라이언트가 자신을 통해서 다른 네트워크 서비스에\\n간접적으로 접속할 수 있게 해주는 컴퓨터나 application을 가리키는데\\n이 프록시 서버는 요청된 내용들을 cache를 이용하여 저장을 한다.\\ncache 안에 있는 정보를 요구하는 요청에 대해서\\n원격 서버에 접속하여 데이터를 가져올 필요가 없게 된다.\\n그리고 외부와의 traffic을 줄여 bottle neck 을 방지한다.\\n\\n- 출처 : https://pjh3749.tistory.com/190 [JayTech의 기술 블로그]</code></pre></div>\\n<ul>\\n<li>브라우저 캐시와 동일한 원리로 동작하며, 네트워크 상에서 동작</li>\\n<li>큰 회사나 IPS의 방화벽에 설치됨</li>\\n<li>한정된 수의 클라이언트를 위해 무한대의 웹 서버 컨텐츠를 캐시</li>\\n</ul>\\n<h3>📍 게이트웨이 캐시 (리버스 프록시)</h3>\\n<ul>\\n<li>서버 앞 단에 설치되어 요청에 대한 캐시 효율적 분배를 통해 가용성과 신뢰성 향상</li>\\n<li>암호화, 로드 밸런싱, 정적 컨텐츠, 압축 등을 수행</li>\\n<li>무한대의 클라이언트에게 한정된 수의 웹 서버 컨텐츠를 제공</li>\\n</ul>\\n<hr>\\n<h2>👻 오늘의 Summary</h2>\\n<p>프록시, 캐시에 대해서 공부했는데, 그동안 제대로 공부해보지 못하고 들어만 본 부분이어서 꼼꼼하게 공부하려고 노력했다. 노력은 했으나, 아직 확실하게 이해 못한 부분이 많은 듯. 특히 게이트웨이랑 프록시가 이해가 잘 안된다. 내일 조금 더 공부해보고 책은 2장의 리퍼러, 검색 엔진 부분을 마무리해야겠다.</p>","frontmatter":{"subject":["프록시","캐시"],"date":"2020-03-12"}}}]}}}')}}]);
//# sourceMappingURL=component---src-templates-til-template-js-167380fc2881b9125e18.js.map