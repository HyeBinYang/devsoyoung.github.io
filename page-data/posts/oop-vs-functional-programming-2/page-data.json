{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/oop-vs-functional-programming-2/","webpackCompilationHash":"3c6974b8e282bd4335be","result":{"data":{"markdownRemark":{"id":"2c2fbd35-7f7f-5206-a852-a198a5433996","html":"<p>앞의 글에서 객체지향 프로그래밍이 왜 필요한지, 객체지향 프로그래밍이 무엇인지에 대해 정리했습니다. 이번 글에서는 함수형 프로그래밍이 왜 등장했는지 무엇인지에 대해 정리해보려고 합니다.</p>\n<h2 id=\"before-functional-programming\"><a href=\"#before-functional-programming\" aria-label=\"before functional programming permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Before Functional Programming</h2>\n<p>함수형 프로그래밍에 대해 논하기 전에 앞서 함수에 대해 정리해봅시다. 우리가 아는 일반적인 함수는 입력에 따라 어떠한 동작을 수행해서 출력을 합니다.</p>\n<h3 id=\"side-effect\"><a href=\"#side-effect\" aria-label=\"side effect permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Side-Effect</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">square</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x <span class=\"token operator\">*</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">x</code>를 입력받아서 <code class=\"language-text\">x * x</code>를 반환합니다. 하지만 함수에는 코드상에서 명시적으로 보이지 않는 입력과 출력이 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Calculator</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">plus</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    number <span class=\"token operator\">+=</span> x<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Calculator 클래스의 plus 메소드를 봅시다. number라는 변수가 사용됩니다. plus 메소드가 실행되기 전 number의 값, 실행되고 난 후의 plus 값은 함수에 명시적으로 입력되지 않았지만 함수의 실행에 연관됩니다. 이러한 암묵적인 input과 output은 바로 함수의 부작용, side-effect 입니다. 생각지 못한 결과를 가져다 줄 수 있다는 것입니다. </p>\n<p>함수가 side-effect를 가지면 우리는 함수의 signature 만으로 함수가 무슨 동작을 하는지 정확히 알 수 없습니다. 함수의 이름을 아무리 명시적으로 지어도, 함수 내부에서 무슨 짓을 하는지 알려면 내부를 들여다보아야 합니다. </p>\n<p>객체지향과 함수형 프로그래밍은 이러한 side-effect를 바라보는 관점에 다소 차이가 있습니다. 객체지향은 부작용을 ‘객체’라는 경계 내에 최대한 가두는 것이고, 함수형 프로그래밍은 “부작용을 제거”하려는 것입니다.</p>\n<h3 id=\"side-effect-in-debugging\"><a href=\"#side-effect-in-debugging\" aria-label=\"side effect in debugging permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Side-effect in Debugging</h3>\n<p>프로그램에 문제가 발생하여 디버깅하는 상황을 생각해봅시다. </p>\n<p>만약 side-effect가 없는 순수 함수라면 함수에 제대로 된 입력이 들어갔는지, 원하는 출력이 나오는지 함수 자체만 고려하면 됩니다. 하지만 side-effect가 있다면 수행 과정에 영향을 주는 모든 외부 요소를 함께 고려해야 합니다. 디버깅할 때 고려해야 하는 것이 훨씬 늘어나는 것이죠.</p>\n<h3 id=\"side-effect-in-testing\"><a href=\"#side-effect-in-testing\" aria-label=\"side effect in testing permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Side-effect in Testing</h3>\n<p>이번에는 테스트 코드를 작성하는 상황을 고려해봅시다.</p>\n<h2 id=\"what-is-functional-programming\"><a href=\"#what-is-functional-programming\" aria-label=\"what is functional programming permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What is Functional Programming</h2>\n<p>함수형 프로그래밍은 여러 가지로 정의될 수 있겠지만, 가장 핵심은 이러한 “부수효과”를 제거하고 개발하는 방법을 말합니다.</p>\n<h2 id=\"why-need-functional-programming\"><a href=\"#why-need-functional-programming\" aria-label=\"why need functional programming permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why need Functional Programming</h2>\n<blockquote>\n<p>이 부분에 대한 더 자세한 내용은 이 글의 “왜 함수형 프로그래밍이어야 할까?”를 참고해주세요.</p>\n</blockquote>\n<h3 id=\"동시성-프로그래밍\"><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" aria-label=\"동시성 프로그래밍 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동시성 프로그래밍</h3>\n<p>최근 반도체 성능이 한계에 다다르자 CPU 회사들은 하나의 칩 성능을 높이는 대신 여러 개의 칩이 병렬적으로 동작하도록 하여 성능을 높이는 방식을 채택하고 있습니다. 이런 이유로 어플리케이션 코드는 멀티 쓰레드를 이용해 CPU 코어를 최대한 활용해야 합니다.</p>\n<p><img src=\"https://t1.daumcdn.net/cfile/tistory/99F8983359CCF05107\" alt=\"dining_philisophy\"></p>\n<p>멀티쓰레드를 활용한 동시성 문제에서 가장 유명한 Deadlock, 교착상태는 스레드 간에 공유되는 데이터나 상태 값이 변경 가능(mutable)하기 때문에 주로 발생합니다.</p>\n<p>하지만 함수형 프로그래밍에서는 사용하는 모든 데이터가 immutable(불변)하고 부수 효과를 가지고 있지 않습니다. 따라서 멀티쓰레드의 교착상태 문제가 발생하지 않습니다.</p>\n<h3 id=\"그-외\"><a href=\"#%EA%B7%B8-%EC%99%B8\" aria-label=\"그 외 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그 외</h3>\n<p>동시성 프로그래밍 외에도 함수형 프로그래밍은 코드를 테스트 하기 쉽고, 읽기 쉽게(시그니처만으로 )</p>\n<h3 id=\"고차함수\"><a href=\"#%EA%B3%A0%EC%B0%A8%ED%95%A8%EC%88%98\" aria-label=\"고차함수 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>고차함수</h3>\n<p>함수를 파라미터로 받거나 함수를 반환하는 함수</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">makeCounter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">func</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      count <span class=\"token operator\">=</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> count<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h2 id=\"reference\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://medium.com/@jooyunghan/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-fab4e960d263\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(번역) 함수형 프로그래밍이란 무엇인가?</a></li>\n<li><a href=\"http://ruaa.me/why-functional-matters/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">왜 함수형 프로그래밍이 좋을까?</a></li>\n</ul>","fields":{"slug":"/posts/oop-vs-functional-programming-2/","tagSlugs":null},"frontmatter":{"date":"2019-09-03","description":"객체지향 프로그래밍과 함수형 프로그래밍에 대해 정리한 글입니다. 1, 2부로 나뉘어져 있으며 2부인 이 글은 함수형 프로그래밍에 대해 정리하였습니다.","tags":null,"title":"객체지향 프로그래밍과 함수형 프로그래밍(2)","category":"Programming"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/oop-vs-functional-programming-2/"}}}